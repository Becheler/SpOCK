#include "options.h"
#include "moat_prototype.h"
#include "gsl/gsl_poly.h"

///
/// @brief Write output for 2 files per spacecraft.
///
/// @details File scXout.txt contains various keplerian, inertial, and ecef parameters
///           File scXout_LLA.txt is Dr. Aaron Ridley's requested output for gitm
///
/// @see Header files for more info
///
int write_output(
  SPACECRAFT_T *SC,
  int init_flag,
  int choose_tle_to_initialise_orbit,
  int sc_index,
  int n_sc,
  int n_gps,
  int nb_ensembles_min,
  int nb_ensemble_min_per_proc,
  int iProc,
  int nb_ensembles_output_files,
  char name_file_ensembles[30][1000],// !!! the number of columns has to correpond to n_files_ensembles
  double          previous_lat,
  OPTIONS_T       *OPTIONS,
  char earth_fixed_frame[100],
  int write_reference_sc,
  int write_ensembles,
  double constellation_et,
  int nProcs,
  int iDebugLevel,
  int compute_collisions,
  int *start_ensemble,
  int *array_sc,
  CONSTELLATION_T *CONSTELLATION,
  PARAMS_T *PARAMS
)
{
  // if set to 0 then don't write in the given files. if set to 1 the write in given files
  int write_lla = 1;
  int write_rho = 1;
  int write_attitude = 1;
  int write_tle = 1;
  int write_ecef = 1;
  int write_all = 1;

  if ( SC[0].INTEGRATOR.isGPS == 1 )
  {
    write_lla = 0;
    write_rho = 0;
    write_attitude = 0;
    write_tle = 0;
    write_all = 0;
  }

  if ( (iProc == 0) && ( iDebugLevel >= 2 ) )
  {
    printf("-- (write_output) Just got in write_output.(iProc %d)\n", iProc);
  }

  double et_intial_epoch;
  str2et_c(OPTIONS->initial_epoch, &et_intial_epoch);

  // Declarations
  SpiceDouble       xform[6][6];
  double estate[6], jstate[6];

  double total_power;
  int hr, mn, sc;
  char time_local[256], ampm[256];
  double lon_an_dn = 0 ;

  double x[3];
  double lt;
  int eee, fff, sss;
  char    times[256], times_with_milliseconds[256];

  int     ii;
  char text[256];
  char text_time_with_milliseconds[256];
  char text_without_millisecond[256];

  int nProcs_that_are_gonna_run_ensembles;
  nProcs_that_are_gonna_run_ensembles = nProcs;

  if ( nProcs > OPTIONS->nb_ensembles_min )
  {
    nProcs_that_are_gonna_run_ensembles = OPTIONS->nb_ensembles_min;
  }

  // TLE epoch of the GPS or the satellite (if the orbit initialisation of the satellite was done from a TLE)
  if (start_ensemble[sc_index] == 0)
  {
    // if this iProc runs main sc sc_index
    et2utc_c(SC[0].et, "ISOC" , 6, 255 , times);
    sscanf(times, "%4[^\n]",text);
    strncat(text, "/",1);
    strncat(text, &times[5],1);
    strncat(text, &times[6],1);
    strncat(text, "/",1);
    strncat(text, &times[8],1);
    strncat(text, &times[9],1);
    strncat(text, " ",1);

    for (ii = 0; ii<15; ii++)
    {
      strncat(text, &times[11+ii],1);
    }

    et2utc_c(SC[0].et, "ISOC" , 0, 255 , times);
    sscanf(times, "%4[^\n]",text_without_millisecond);
    strncat(text_without_millisecond, "/",1);
    strncat(text_without_millisecond, &times[5],1);
    strncat(text_without_millisecond, &times[6],1);
    strncat(text_without_millisecond, "/",1);
    strncat(text_without_millisecond, &times[8],1);
    strncat(text_without_millisecond, &times[9],1);
    strncat(text_without_millisecond, " ",1);

    for (ii = 0; ii<9; ii++)
    {
      strncat(text_without_millisecond, &times[11+ii],1);
    }

    et2utc_c(SC[0].et, "ISOC" ,6 ,255 , times_with_milliseconds);
    sscanf(times_with_milliseconds, "%4[^\n]",text_time_with_milliseconds);
    strncat(text_time_with_milliseconds, "/",1);
    strncat(text_time_with_milliseconds, &times_with_milliseconds[5],1);
    strncat(text_time_with_milliseconds, &times_with_milliseconds[6],1);
    strncat(text_time_with_milliseconds, "/",1);
    strncat(text_time_with_milliseconds, &times_with_milliseconds[8],1);
    strncat(text_time_with_milliseconds, &times_with_milliseconds[9],1);
    strncat(text_time_with_milliseconds, " ",1);

    for (ii = 0; ii<15; ii++)
    {
      strncat(text_time_with_milliseconds, &times_with_milliseconds[11+ii],1);
    }

  } // end of  if this iProc runs main sc sc_index

  if (init_flag == 1)
  {
    if (start_ensemble[sc_index] == 0)
    {
      // if this iProc runs main sc sc_index

      // Initialization header
      if (write_reference_sc)
      {
        if (write_lla == 1)
        {
          fprintf(SC[0].fpout, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fpout, "// \n");
          fprintf(SC[0].fpout, "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK)\n");
          fprintf(SC[0].fpout, "// Trajectory Spacecraft %s in a constellation of %d spacecraft and %d GPS satellites \n", SC[0].name_sat, n_sc-n_gps, n_gps);

          if ( ( sc_index >= (n_sc - n_gps) ) || ( choose_tle_to_initialise_orbit == 1 ) )
          fprintf(SC[0].fpout ,"// Epoch of last TLE for %s: %s \n",  SC[0].name_sat, text);
          fprintf(SC[0].fpout, "// \n");
          fprintf(SC[0].fpout, "// Trajectory is specified with:  TIME LONGITUDE(DEG) LATITUDE(DEG) ALTITUDE(KM) \n");
          fprintf(SC[0].fpout, "// \n");
          fprintf(SC[0].fpout, "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
          fprintf(SC[0].fpout, "// \n");
          fprintf(SC[0].fpout, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fpout, "#START \n");
        }

        if (write_rho == 1)
        {
          fprintf(SC[0].fprho, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fprho, "// \n");
          fprintf(SC[0].fprho, "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK) \n");
          fprintf(SC[0].fprho, "// Trajectory Spacecraft %s in a constellation of %d spacecraft and %d GPS satellites \n", SC[0].name_sat, n_sc-n_gps, n_gps);

          if (sc_index >= (n_sc - n_gps))
          fprintf(SC[0].fprho ,"// Epoch of last TLE for %s: %s \n",  SC[0].name_sat, text);
          fprintf(SC[0].fprho, "// \n");
          fprintf(SC[0].fprho, "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
          fprintf(SC[0].fprho, "// \n");
          fprintf(SC[0].fprho, "// Atmosphere info: \n");
          fprintf(SC[0].fprho, "// TIME DENSITY(kg/km^3) TEMP(K) CD_TOT_NORM A_REF_TOT(km^2) BC*mass(m^2)");

          fprintf(SC[0].fprho,"\n");
          fprintf(SC[0].fprho, "// ---------------------------------------------------------------------------------- \n");
        }

        if (write_attitude == 1)
        {
          fprintf(SC[0].fpatt, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fpatt, "// \n");
          fprintf(SC[0].fpatt, "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK)\n");
          fprintf(SC[0].fpatt, "// Attitude Spacecraft %s in a constellation of %d spacecraft and %d GPS satellites \n", SC[0].name_sat, n_sc-n_gps, n_gps);
          if ( ( sc_index >= (n_sc - n_gps) ) || ( choose_tle_to_initialise_orbit == 1 ) )
          fprintf(SC[0].fpatt ,"// Epoch of last TLE for %s: %s \n",  SC[0].name_sat, text);
          fprintf(SC[0].fpatt, "// \n");
          fprintf(SC[0].fpatt, "// Attitude is specified with:  TIME PITCH(DEG) ROLL(DEG) YAW(DEG) ORDER_PITCH ORDER_ROLL ORDER_YAW \n");
          fprintf(SC[0].fpatt, "// \n");
          fprintf(SC[0].fpatt, "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
          fprintf(SC[0].fpatt, "// \n");
          fprintf(SC[0].fpatt, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fpatt, "#START \n");
        }

        // Initialization header for TLE output file
        if (sc_index < n_sc - n_gps)
        {
          if ( choose_tle_to_initialise_orbit == 1 )
          {
            if ( write_tle == 1 )
            {
              fprintf(SC[0].fptle, "// ---------------------------------------------------------------------------------- \n");
              fprintf(SC[0].fptle, "// \n");
              fprintf(SC[0].fptle, "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK) \n");
              fprintf(SC[0].fptle, "// Trajectory Spacecraft %s in a constellation of %d spacecraft and %d GPS satellites \n", SC[0].name_sat, n_sc-n_gps, n_gps);
              fprintf(SC[0].fptle ,"// This file shows the position of satellite %s from its TLE epoch start (%s) to the constellation epoch start (%s)\n",  SC[0].name_sat, text_time_with_milliseconds, OPTIONS->initial_epoch);
              fprintf(SC[0].fptle, "// \n");
              fprintf(SC[0].fptle, "// Trajectory is specified with: TIME  \t\tr_i2cg_INRTL(3)(KM) \t\t     v_i2cg_INRTL(3)(KM/S) \t      LONG(DEG)    LAT(DEG)     ALT(KM)       SMA(KM)     INC(DEG)      ECC       TRUE ANO(DEG)  RAAN(DEG) ARG PERIG(DEG) RIGHT ASC(DEG) LOCAL TIME(DEG)  a_i2cg_INRTL(3)(KM/S^2) r_ecef2cg_ECEF(3)(KM) v_ecef2cg_ECEF(3)(KM)\n");
              fprintf(SC[0].fptle, "// \n");
              fprintf(SC[0].fptle, "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
              fprintf(SC[0].fptle, "// \n");
              fprintf(SC[0].fptle, "// ---------------------------------------------------------------------------------- \n");
              fprintf(SC[0].fptle, "#START \n");
            }
          }
        }

        // Initialization header
        if (write_ecef == 1)
        {
          fprintf(SC[0].fpecef, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fpecef, "// \n");
          fprintf(SC[0].fpecef, "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK) \n");
          fprintf(SC[0].fpecef, "// Trajectory Spacecraft %s in a constellation of %d spacecraft and %d GPS satellites (iProc %d)\n", SC[0].name_sat, n_sc-n_gps, n_gps, iProc);
          if (sc_index >= (n_sc - n_gps))
          fprintf(SC[0].fpecef ,"// Epoch of last TLE for %s: %s \n",  SC[0].name_sat, text);
          fprintf(SC[0].fpecef, "// \n");
          fprintf(SC[0].fpecef, "// Trajectory is specified with: \n");
          fprintf(SC[0].fpecef, "//\tTIME  \t\t      r_ecef2cg_ECEF(3)(KM) \t\t  v_ecef2cg_ECEF(3)(KM/S)\n");
          fprintf(SC[0].fpecef, "// \n");
          fprintf(SC[0].fpecef, "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
          fprintf(SC[0].fpecef, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fpecef, "#START \n");
        }

        // Initialization header
        if (write_all == 1)
        {
          fprintf(SC[0].fp, "// ---------------------------------------------------------------------------------- \n");
          fprintf(SC[0].fp, "// \n");
          fprintf(SC[0].fp, "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK) \n");
          fprintf(SC[0].fp, "// Trajectory Spacecraft %s in a constellation of %d spacecraft and %d GPS satellites \n", SC[0].name_sat, n_sc-n_gps, n_gps);
          if (sc_index >= (n_sc - n_gps))
          fprintf(SC[0].fp ,"// Epoch of last TLE for %s: %s \n",  SC[0].name_sat, text);
          fprintf(SC[0].fp, "// \n");
          fprintf(SC[0].fp, "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
          fprintf(SC[0].fp, "// \n");
          fprintf(SC[0].fp, "// Trajectory is specified with: \n");
          fprintf(SC[0].fp, "//    ET  \t\tr_i2cg_INRTL(3)(KM) \t\t     v_i2cg_INRTL(3)(KM/S) \t      LONG(DEG)    LAT(DEG)     ALT(KM)       SMA(KM)     INC(DEG)      ECC       TRUE ANO(DEG)  RAAN(DEG) ARG PERIG(DEG) RIGHT ASC(DEG) LOCAL TIME(DEG)  a_i2cg_INRTL(3)(KM/S^2) a_i2cg_LVLH(3)(KM/S^2) a_i2cg_LVLH_gravity(3)(KM/S^2) a_i2cg_LVLH_drag(3)(KM/S^2) a_i2cg_INRTL_drag(3)(KM/S^2) a_i2cg_INRTL_gravity(3)(KM/S^2) beta_angle(deg) PHASE_ANGLE(DEG) ARG_PERIG_AVER(DEG) SMA_AVER(KM) ECC_AVER SOLAR_ZENITH(DEG)");
          fprintf(SC[0].fp,"\n");
          fprintf(SC[0].fp, "// ---------------------------------------------------------------------------------- \n");
        }
      }


      if (sc_index < n_sc - n_gps){
        if (write_reference_sc == 1){
          // Initialization header for power file
          if (SC[0].INTEGRATOR.solar_cell_efficiency != -1){
            fprintf(SC[0].fpower, "// ---------------------------------------------------------------------------------- \n");
            fprintf(SC[0].fpower, "// \n");
            fprintf(SC[0].fpower, "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK) \n");
            fprintf(SC[0].fpower, "// Spacecraft power %s in a constellation of %i spacecraft and %d GPS satellites\n", SC[0].name_sat, n_sc - n_gps, n_gps);
            fprintf(SC[0].fpower, "// Number of surfaces: %f \n", SC[0].INTEGRATOR.nb_surfaces);
            fprintf(SC[0].fpower, "// \n");
            fprintf(SC[0].fpower, "// Trajectory is specified with:  TIME POWER(W) LIGHT/SHADOW SUN_ELEVATION\n");
            fprintf(SC[0].fpower, "// Sun elevation angle counted from body xy plane (positive if Sun in the direction of +z body) (-999 if satellite is not in the light)\n");
            fprintf(SC[0].fpower, "// \n");
            fprintf(SC[0].fpower, "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
            fprintf(SC[0].fpower, "// \n");
            fprintf(SC[0].fpower, "// ---------------------------------------------------------------------------------- \n");
            fprintf(SC[0].fpower, "#START \n");
          }
        }
      }
    } // end of  if this iProc runs main sc sc_index

    if (sc_index < n_sc - n_gps)
    {
      // Initialization header
      // ensembles in COE
      if ( nb_ensemble_min_per_proc > 0 )
      {
        if ( array_sc[1] > 0 )
        {
          // if this iProc runs ensembles (otherwise array_sc[1] = - 1)
          for (fff = 0; fff < nb_ensembles_output_files ; fff ++)
          {
            if ( (strcmp(OPTIONS->filename_output_ensemble[fff], "tca" )!= 0 ) && (strcmp(OPTIONS->filename_output_ensemble[fff], "dca" )!= 0 ) && (strcmp(OPTIONS->filename_output_ensemble[fff], "sample" )!= 0 ))
            {
              fprintf(SC[0].fpiproc[fff], "// ---------------------------------------------------------------------------------- \n");
              fprintf(SC[0].fpiproc[fff], "// \n");
              fprintf(SC[0].fpiproc[fff], "// Please note this file is auto generated by the Spacecraft Orbital Characterization Kit (SpOCK) \n");
              fprintf(SC[0].fpiproc[fff], "// Ensembles in a constellation of %d spacecraft and %d GPS satellites \n",  n_sc-n_gps, n_gps);
              fprintf(SC[0].fpiproc[fff], "// \n");
              fprintf(SC[0].fpiproc[fff], "// Trajectory is specified with:  time %s (%d ensembles - %d processors) \n", name_file_ensembles[fff], nb_ensembles_min, nProcs_that_are_gonna_run_ensembles);
              fprintf(SC[0].fpiproc[fff], "// \n");
              fprintf(SC[0].fpiproc[fff], "// Version control of SpOCK is under Joel Getchius's Mac and Charles Bussy-Virat's Mac \n");
              fprintf(SC[0].fpiproc[fff], "// \n");
              fprintf(SC[0].fpiproc[fff], "// ---------------------------------------------------------------------------------- \n");
              fprintf(SC[0].fpiproc[fff], "#START");
            }
          }
        } // end of if this iProc runs ensembles (otherwise array_sc[1] = - 1)
      }
    }

    if ( ( sc_index >= n_sc - n_gps) || ( choose_tle_to_initialise_orbit == 1 ) )
    {
      return 0;
    }
  }

  /* Write the results in the TLE format file */
  if (start_ensemble[sc_index] == 0)
  {
    // if this iProc runs main sc sc_index
    if (write_reference_sc == 1)
    {
      if ( init_flag == 2  )
      {
        // init_flag = 2 means that we write the positions of the satellite from its TLE epoch start to the constellation epoch start
        if (write_tle==1)
        {
          fprintf(SC[0].fptle, "%s", text_time_with_milliseconds );
          fprintf(SC[0].fptle, " " );
          fprintf(SC[0].fptle, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f\n",
          SC[0].r_i2cg_INRTL[0],
          SC[0].r_i2cg_INRTL[1],
          SC[0].r_i2cg_INRTL[2],
          SC[0].v_i2cg_INRTL[0],
          SC[0].v_i2cg_INRTL[1],
          SC[0].v_i2cg_INRTL[2],
          (SC[0].GEODETIC.longitude * RAD2DEG),
          (SC[0].GEODETIC.latitude  * RAD2DEG),
          SC[0].GEODETIC.altitude,
          SC[0].OE.sma,
          (SC[0].OE.inclination * RAD2DEG),
          (SC[0].OE.eccentricity),
          (SC[0].OE.f * RAD2DEG),
          (SC[0].OE.long_an*RAD2DEG),
          (SC[0].OE.w*RAD2DEG),
          SC[0].OE.ra*RAD2DEG,
          SC[0].r_ecef2cg_ECEF[0],
          SC[0].r_ecef2cg_ECEF[1],
          SC[0].r_ecef2cg_ECEF[2],
          SC[0].v_ecef2cg_ECEF[0],
          SC[0].v_ecef2cg_ECEF[1],
          SC[0].v_ecef2cg_ECEF[2]);
        }
        return 0;
      } // end of init_flag = 2 means that we write the positions of the satellite from its TLE epoch start to the constellation epoch start
    } // end of if (write_reference_sc == 1)

    /* Write the results in the detailed format file */
    if (write_reference_sc == 1)
    {
      if (write_all == 1)
      {
        fprintf(SC[0].fp, "%s", text );
        fprintf(SC[0].fp, " " );
        fprintf(SC[0].fp, "%.10f %.10f %.10f %.10f %.10f %.10f %f %f %f %f %f %f %f %f %f %f",
        SC[0].r_i2cg_INRTL[0],
        SC[0].r_i2cg_INRTL[1],
        SC[0].r_i2cg_INRTL[2],
        SC[0].v_i2cg_INRTL[0],
        SC[0].v_i2cg_INRTL[1],
        SC[0].v_i2cg_INRTL[2],
        (SC[0].GEODETIC.longitude * RAD2DEG),
        (SC[0].GEODETIC.latitude  * RAD2DEG),
        SC[0].GEODETIC.altitude,
        SC[0].OE.sma,
        (SC[0].OE.inclination * RAD2DEG),
        (SC[0].OE.eccentricity),
        (SC[0].OE.f * RAD2DEG),
        (SC[0].OE.long_an*RAD2DEG),
        (SC[0].OE.w*RAD2DEG),
        SC[0].OE.ra*RAD2DEG);

        // !!! OUTPUT THE LOCAL TIME OF THE SATELLITE (IN DEGREES).
        et2lst_c ( SC[0].et,  399,  SC[0].GEODETIC.longitude, "PLANETOCENTRIC", 51, 51,
        &hr, &mn,  &sc,  time_local, ampm             );
        lon_an_dn = fmod( ( hr + mn / 60.0 + sc / 3600.0 ) * 15 , 360);
        fprintf(SC[0].fp, " %f", lon_an_dn);

        // !!! OUTPUT THE LOCAL TIME OF THE SATELLITE (IN DEGREES).
        fprintf(SC[0].fp, " %11.10f %11.10f %11.10f", SC[0].a_i2cg_INRTL[0], SC[0].a_i2cg_INRTL[1], SC[0].a_i2cg_INRTL[2]);
        fprintf(SC[0].fp, " %e %e %e %e %e %e %e %e %e %e %e %e %e %e %e", SC[0].a_i2cg_LVLH[0], SC[0].a_i2cg_LVLH[1], SC[0].a_i2cg_LVLH[2], SC[0].a_i2cg_LVLH_gravity[0], SC[0].a_i2cg_LVLH_gravity[1], SC[0].a_i2cg_LVLH_gravity[2], SC[0].a_i2cg_LVLH_drag[0], SC[0].a_i2cg_LVLH_drag[1], SC[0].a_i2cg_LVLH_drag[2], SC[0].a_i2cg_INRTL_drag[0], SC[0].a_i2cg_INRTL_drag[1], SC[0].a_i2cg_INRTL_drag[2],  SC[0].a_i2cg_INRTL_gravity[0], SC[0].a_i2cg_INRTL_gravity[1], SC[0].a_i2cg_INRTL_gravity[2]);
        fprintf(SC[0].fp, " %f", SC[0].INTEGRATOR.beta_angle*RAD2DEG);
        fprintf(SC[0].fp, " %f", SC[0].OE.an_to_sc*RAD2DEG);

        char orbnumber[10];
        strcpy(orbnumber, "");

        if  ( ( (SC[0].et - SC[0].et_last_orbit ) < OPTIONS->dt_output ) )
        {
          fprintf(SC[0].fp, " %f", SC[0].OE.w_ave*RAD2DEG);
          fprintf(SC[0].fp, " %f", SC[0].OE.sma_ave);
          fprintf(SC[0].fp, " %f", SC[0].OE.ecc_ave);
        }
        else
        {
          fprintf(SC[0].fp, " 9999.999999"); // w_ave
          fprintf(SC[0].fp, " 9999.999999"); // sma_ave
          fprintf(SC[0].fp, " 9999.999999"); // ecc_ave
        }

        fprintf(SC[0].fp, " %f", SC[0].OE.zenith*RAD2DEG);
        if  ( ( (SC[0].et - SC[0].et_last_orbit ) < OPTIONS->dt_output ) )
        {
          fprintf(SC[0].fp, " ORB");
          strcpy(orbnumber, "");
          sprintf(orbnumber, "%d", SC[0].orbit_number);
          fprintf(SC[0].fp, "%s", orbnumber);
        }

        if ( ( SC[0].GEODETIC.latitude  * RAD2DEG < 0.15 ) && ( SC[0].GEODETIC.latitude  * RAD2DEG > -0.15 ) )
        {
          // Return the state (position and velocity) of a target body relative to an observing body, optionally corrected for light time (planetary aberration) and stellar aberration.
          spkez_c(10, SC[0].et, "J2000", "NONE", 399, x, &lt);
          et2lst_c(SC[0].et,
                   399,
                   SC[0].GEODETIC.longitude,
                   "PLANETOCENTRIC",
                   51,
                   51,
                   &hr,
                   &mn,
                   &sc,
                   time_local,
                   ampm);

          lon_an_dn = fmod( ( hr + mn / 60.0 + sc / 3600.0 ) * 15 , 360);

          if ( SC[0].GEODETIC.latitude  * RAD2DEG - previous_lat > 0 )
          {
            fprintf(SC[0].fp, " %s %s", time_local, "AN");
          }
          else
          {
            fprintf(SC[0].fp, " %5.2f %s", lon_an_dn, "DN");
            et2utc_c(SC[0].et, "ISOC" ,0 ,255 , times);
          }
        }
        fprintf(SC[0].fp, "\n");
      }

      //  double T_J2000_to_ECEF[3][3];
      double geodetic[3];
      if (init_flag == 1)
      {
        estate[0] = SC[0].r_i2cg_INRTL[0];estate[1] = SC[0].r_i2cg_INRTL[1];estate[2] = SC[0].r_i2cg_INRTL[2];
        estate[3] = SC[0].v_i2cg_INRTL[0];estate[4] = SC[0].v_i2cg_INRTL[1];estate[5] = SC[0].v_i2cg_INRTL[2];
        sxform_c (  "J2000", earth_fixed_frame,  SC[0].et,    xform  );
        mxvg_c   (  xform,       estate,   6,  6, jstate );
        SC[0].r_ecef2cg_ECEF[0] = jstate[0]; SC[0].r_ecef2cg_ECEF[1] = jstate[1]; SC[0].r_ecef2cg_ECEF[2] = jstate[2];
        SC[0].v_ecef2cg_ECEF[0] = jstate[3]; SC[0].v_ecef2cg_ECEF[1] = jstate[4]; SC[0].v_ecef2cg_ECEF[2] = jstate[5];
      }

      if (write_ecef == 1)
      {
        fprintf(SC[0].fpecef, "%s", text_without_millisecond);
        fprintf(SC[0].fpecef, " " );
        fprintf(SC[0].fpecef, "%.10f %.10f %.10f %.10f %.10f %.10f\n",
        SC[0].r_ecef2cg_ECEF[0],
        SC[0].r_ecef2cg_ECEF[1],
        SC[0].r_ecef2cg_ECEF[2],
        SC[0].v_ecef2cg_ECEF[0],
        SC[0].v_ecef2cg_ECEF[1],
        SC[0].v_ecef2cg_ECEF[2]);
      }

      /* write the results in the density file */
      if (write_rho == 1)
      {
        /// @warning In output A_ref_tot in km^2 */
        fprintf(SC[0].fprho,"%s %e %f %f %e %e\n", text, SC[0].density_here, SC[0].INTEGRATOR.Ta, SC[0].INTEGRATOR.cd_tot_norm, SC[0].INTEGRATOR.A_ref_tot/1000000., SC[0].INTEGRATOR.sum_cd_a_cos * 1000000);
      }

      /* Write the results in the LLA format file */
      if(  write_lla ==1 )
      {
        fprintf(SC[0].fpout, "%s", text );
        fprintf(SC[0].fpout, " " );

        fprintf(SC[0].fpout, "%6.3f %6.3f %6.3f \n",
        SC[0].GEODETIC.longitude * RAD2DEG,
        SC[0].GEODETIC.latitude  * RAD2DEG,
        SC[0].GEODETIC.altitude);
      }

      if(  write_attitude ==1 )
      {
        fprintf(SC[0].fpatt, "%s", text );
        fprintf(SC[0].fpatt, " " );
        fprintf(SC[0].fpatt, "%6.3f %6.3f %6.3f %d %d %d \n",
        SC[0].INTEGRATOR.attitude.pitch_current,
        SC[0].INTEGRATOR.attitude.roll_current,
        SC[0].INTEGRATOR.attitude.yaw_current,
        SC[0].INTEGRATOR.attitude.order_pitch_current,
        SC[0].INTEGRATOR.attitude.order_roll_current,
        SC[0].INTEGRATOR.attitude.order_yaw_current	    );
      }
    }
  } // end of if this iProc runs main sc sc_index

  if (sc_index < n_sc - n_gps)
  {
    // if main sc is not a GPS
    if ((init_flag != 1 ) || (compute_collisions != 1))
    {
      if (write_ensembles == 1)
      {
        char text[256];
        et2utc_c(constellation_et, "ISOC" ,0 ,255 , times);
        sscanf(times, "%4[^\n]",text);
        strncat(text, "/",1);
        strncat(text, &times[5],1);
        strncat(text, &times[6],1);
        strncat(text, "/",1);
        strncat(text, &times[8],1);
        strncat(text, &times[9],1);
        strncat(text, " ",1);

        for (ii = 0; ii<8; ii++)
        {
          strncat(text, &times[11+ii],1);
        }

        // Write the results in the ensemble file
        // ensemble in COE
        if ( nb_ensembles_min > 0 )
        {
          if (( iDebugLevel >= 3 ) )
          {
            printf("---- (write_output) Writing results of ensembles.(iProc %d)\n", iProc);
          }
          if ( array_sc[1] > 0 )
          { // if this iProc runs ensembles (otherwise array_sc[1] = - 1)
            for (fff = 0; fff < nb_ensembles_output_files ; fff ++)
            {
              if ( (strcmp(OPTIONS->filename_output_ensemble[fff], "tca" )!= 0 ) && (strcmp(OPTIONS->filename_output_ensemble[fff], "dca" )!= 0 ) && (strcmp(OPTIONS->filename_output_ensemble[fff], "sample" )!= 0 ) )
              {
                fprintf(SC[0].fpiproc[fff], "\n%s", text );
                fprintf(SC[0].fpiproc[fff], " " );
                if ( strcmp( name_file_ensembles[fff], "x_eci" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].r_i2cg_INRTL[0]);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "y_eci" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++){
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].r_i2cg_INRTL[1]);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "z_eci" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].r_i2cg_INRTL[2]);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "vx_eci" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].v_i2cg_INRTL[0]);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "vy_eci" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].v_i2cg_INRTL[1]);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "vz_eci" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].v_i2cg_INRTL[2]);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "latitude" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].GEODETIC.latitude * RAD2DEG);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "longitude" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].GEODETIC.longitude * RAD2DEG);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "altitude" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].GEODETIC.altitude);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "power" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    total_power = 0.0;
                    for (sss = 0; sss < SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.nb_surfaces; sss++)
                    {
                      //SC[0].INTEGRATOR.nb_surfaces
                      total_power = total_power + SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.surface[sss].power_per_surface;
                    }
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    total_power);
                  }
                }
                // output the attitude for the ensembles assumes that either one of these was chosen in the input file: solar power, solar pressure, drag, coverage ground station
                else if ( strcmp( name_file_ensembles[fff], "pitch" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.attitude.pitch_current);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "roll" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.attitude.roll_current);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "yaw" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.attitude.yaw_current);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "sma" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].OE.sma);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "inclination" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].OE.inclination*RAD2DEG);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "eccentricity" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].OE.eccentricity);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "true_anomaly" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].OE.f*RAD2DEG);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "RAAN" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].OE.long_an*RAD2DEG);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "argument_perigee" ) == 0 )
                {
                  for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                  {
                    fprintf(SC[0].fpiproc[fff], "%.9f ",
                    SC[eee + iProc * nb_ensemble_min_per_proc].OE.w*RAD2DEG);
                  }
                }
                else if ( strcmp( name_file_ensembles[fff],"rho" ) == 0 )
                {
                  if (OPTIONS->include_drag == 1)
                  {
                    for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                    {
                      fprintf(SC[0].fpiproc[fff], "%.9f ",
                      SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.density[SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.index_in_driver_interpolated]);
                    }
                  }
                }

                else if ( strcmp( name_file_ensembles[fff], "f107" ) == 0 )
                {
                  if (OPTIONS->include_drag == 1)
                  {
                    for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                    {
                      if ( strcmp(OPTIONS->format_density_driver, "static") == 0 )
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9f ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.f107_static);
                      }
                      else
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9f ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.f107[SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.index_in_driver_interpolated]);
                      }
                    }
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "f107a" ) == 0 )
                {
                  if (OPTIONS->include_drag == 1)
                  {
                    for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                    {
                      if ( strcmp(OPTIONS->format_density_driver, "static") == 0 )
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9f ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.f107A_static);
                      }
                      else
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9f ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.f107A[SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.index_in_driver_interpolated]);
                      }
                    }
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "ap" ) == 0 )
                {
                  if (OPTIONS->include_drag == 1)
                  {
                    for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                    {
                      if ( strcmp(OPTIONS->format_density_driver, "static") == 0 )
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9f ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.Ap_static);
                      }
                      else
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9f ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.Ap[SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.index_in_driver_interpolated]);
                      }
                    }
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "cd" ) == 0 )
                {
                  if (OPTIONS->include_drag == 1)
                  {
                    if (strcmp(OPTIONS->type_orbit_initialisation, "collision_vcm" ) == 0 )
                    {
                      // if collision with vcm then the bc is input rom the VCM (or CDM). here not a cd but a bc.
                      for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9e ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.bc_vcm* 1000. * 1000); // in m2/kg
                      }
                      SC[0].already_output_cd_ensemble = 1;
                    }
                    else
                    {
                      for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9e ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.surface[0].Cd);
                        // only the first surface
                      }
                    }
                  }
                }
                else if ( strcmp( name_file_ensembles[fff], "srp" ) == 0 )
                {
                  if (OPTIONS->include_solar_pressure == 1)
                  {
                    if (strcmp(OPTIONS->type_orbit_initialisation, "collision_vcm" ) == 0 )
                    {
                      // if collision with vcm then the bc is input rom the VCM (or CDM). here not a cd but a bc.
                      for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9e ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.srp_vcm * 1000. * 1000); // in m2/kg
                      }
                      SC[0].already_output_srp_ensemble = 1;
                    }
                    else
                    {
                      for (eee = 1L; eee< nb_ensemble_min_per_proc + 1; eee++)
                      {
                        fprintf(SC[0].fpiproc[fff], "%.9e ",
                        SC[eee + iProc * nb_ensemble_min_per_proc].INTEGRATOR.surface[0].solar_radiation_coefficient); // only the first surface
                      }
                    }
                  }
                }
              } // end of if ensemble to plot is not dca or tca
            } // end of going through all ensemble files
          }   // end of if this iProc runs ensembles (otherwise array_sc[1] = - 1)
        }

        if (( iDebugLevel >= 3 ) )
        {
          printf("---- (write_output) Done results of ensembles.(iProc %d)\n", iProc);
        }
      }
    }

    if (start_ensemble[sc_index] == 0)
    {
      // if this iProc runs main sc sc_index
      if (write_reference_sc == 1)
      {
        /* Write the results on the power in the power file */
        if (SC[0].INTEGRATOR.solar_cell_efficiency != -1)
        {
          fprintf(SC[0].fpower, "%s", text );
          fprintf(SC[0].fpower, " " );
          for (sss = 0; sss < SC[0].INTEGRATOR.nb_surfaces; sss++)
          {
            //SC[0].INTEGRATOR.nb_surfaces
            fprintf(SC[0].fpower,"%5.2f ",
            SC[0].INTEGRATOR.surface[sss].power_per_surface);
          }

          fprintf(SC[0].fpower,"%s ",
          SC[0].INTEGRATOR.shadow);

          fprintf(SC[0].fpower,"%f ",
          SC[0].INTEGRATOR.sun_elevation*RAD2DEG);

          fprintf(SC[0].fpower, "\n");

          // sc in elcipse of Moon if sc in shadow of Moon and sc not in shadow of Earth
          if ( ( strcmp(SC[0].INTEGRATOR.shadow, "light") == 0 ) && ( strcmp(SC[0].INTEGRATOR.shadow_moon, "light") != 0 ) )
          {
            fprintf(SC[0].fpeclipse,"%s\n", text);
          }
        }
      }
    } // end of if this iProc runs main sc sc_index
  }  // end of if main sc is not a GPS

  if ( (iProc == 0) && ( iDebugLevel >= 2 ) )
  {
    printf("-- (write_output) Just got out of write_output.(iProc %d)\n", iProc);
  }
  return 0;
}
